<!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Network Latency Monitor - AI Enhanced</title>
         <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
         <style>
             * {
                 margin: 0;
                 padding: 0;
                 box-sizing: border-box;
             }

             :root {
                 --bg-primary: #0f172a;
                 --bg-secondary: #1e293b;
                 --bg-card: #334155;
                 --text-primary: #f1f5f9;
                 --text-secondary: #cbd5e1;
                 --accent: #3b82f6;
                 --success: #10b981;
                 --warning: #f59e0b;
                 --danger: #ef4444;
                 --border: #475569;
                 --mcp-accent: #8b5cf6; /* New MCP AI color */
                 --ai-glow: #a855f7;
                 --opacity: 1; /* For quiet hours dimming */
             }

             /* Light theme variables */
             :root.light-theme {
                 --bg-primary: #f8fafc;
                 --bg-secondary: #f1f5f9;
                 --bg-card: #ffffff;
                 --text-primary: #1e293b;
                 --text-secondary: #64748b;
                 --border: #e2e8f0;
             }

             /* Quiet hours dimming */
             body.quiet-hours {
                 --opacity: 0.7;
                 filter: brightness(0.8);
             }

             body.quiet-hours .ai-badge {
                 animation: none; /* Stop glowing during quiet hours */
             }

             body {
                 font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                 background: var(--bg-primary);
                 color: var(--text-primary);
                 line-height: 1.6;
             }

             .container {
                 max-width: 1600px; /* Wider for AI panel */
                 margin: 0 auto;
                 padding: 20px;
             }

             .header {
                 display: flex;
                 justify-content: space-between;
                 align-items: center;
                 margin-bottom: 30px;
                 flex-wrap: wrap;
                 gap: 20px;
             }

             h1 {
                 font-size: 2rem;
                 font-weight: 700;
                 display: flex;
                 align-items: center;
                 gap: 10px;
             }

             .ai-badge {
                 background: linear-gradient(135deg, var(--mcp-accent), var(--ai-glow));
                 color: white;
                 padding: 4px 12px;
                 border-radius: 20px;
                 font-size: 0.7rem;
                 font-weight: 600;
                 text-transform: uppercase;
                 letter-spacing: 0.5px;
                 animation: glow 2s ease-in-out infinite alternate;
             }

             @keyframes glow {
                 from { box-shadow: 0 0 5px var(--mcp-accent); }
                 to { box-shadow: 0 0 15px var(--ai-glow), 0 0 25px var(--mcp-accent); }
             }

             .status-bar {
                 display: flex;
                 align-items: center;
                 gap: 20px;
                 flex-wrap: wrap;
             }

             .last-update {
                 color: var(--text-secondary);
                 font-size: 0.9rem;
             }

             .toggle-btn {
                 background: var(--bg-card);
                 border: 1px solid var(--border);
                 color: var(--text-primary);
                 padding: 8px 16px;
                 border-radius: 8px;
                 cursor: pointer;
                 transition: all 0.3s ease;
                 display: flex;
                 align-items: center;
                 gap: 8px;
             }

             .toggle-btn:hover {
                 background: var(--border);
             }

             .toggle-btn.active {
                 background: var(--accent);
                 border-color: var(--accent);
             }

             .toggle-btn.ai-mode {
                 background: linear-gradient(135deg, var(--mcp-accent), var(--ai-glow));
                 border-color: var(--mcp-accent);
             }

             .toggle-btn.ai-mode:hover {
                 background: linear-gradient(135deg, var(--ai-glow), var(--mcp-accent));
             }

             /* Main Layout - Now with sidebar for AI */
             .main-layout {
                 display: grid;
                 grid-template-columns: 1fr 400px; /* Main content + AI sidebar */
                 gap: 30px;
                 margin-bottom: 30px;
             }

             .main-content {
                 min-width: 0; /* Prevents overflow */
             }

             .ai-sidebar {
                 background: var(--bg-secondary);
                 border: 1px solid var(--border);
                 border-radius: 12px;
                 padding: 20px;
                 height: fit-content;
                 position: sticky;
                 top: 20px;
             }

             .ai-sidebar.hidden {
                 display: none;
             }

             /* Responsive - Stack on mobile */
             @media (max-width: 1200px) {
                 .main-layout {
                     grid-template-columns: 1fr;
                 }

                 .ai-sidebar {
                     order: -1; /* Show AI insights first on mobile */
                 }
             }

             .stats-grid {
                 display: grid;
                 grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                 gap: 20px;
                 margin-bottom: 30px;
             }

             .stat-card {
                 background: var(--bg-secondary);
                 border: 1px solid var(--border);
                 border-radius: 12px;
                 padding: 20px;
                 text-align: center;
                 transition: all 0.3s ease;
             }

             .stat-card:hover {
                 border-color: var(--accent);
                 transform: translateY(-2px);
             }

             .stat-number {
                 font-size: 2.5rem;
                 font-weight: 700;
                 margin-bottom: 5px;
             }

             .stat-label {
                 color: var(--text-secondary);
                 font-size: 0.9rem;
                 font-weight: 500;
             }

             .stat-card.online .stat-number { color: var(--success); }
             .stat-card.offline .stat-number { color: var(--danger); }
             .stat-card.latency .stat-number { color: var(--accent); }

             /* AI Insights Panel Styles */
             .ai-panel-header {
                 display: flex;
                 align-items: center;
                 gap: 10px;
                 margin-bottom: 20px;
                 padding-bottom: 15px;
                 border-bottom: 2px solid var(--mcp-accent);
             }

             .ai-panel-header h3 {
                 color: var(--mcp-accent);
                 font-size: 1.2rem;
             }

             .ai-score-gauge {
                 background: var(--bg-card);
                 border-radius: 12px;
                 padding: 20px;
                 text-align: center;
                 margin-bottom: 20px;
                 position: relative;
                 overflow: hidden;
             }

             .ai-score-gauge::before {
                 content: '';
                 position: absolute;
                 top: 0;
                 left: 0;
                 right: 0;
                 bottom: 0;
                 background: linear-gradient(135deg, var(--mcp-accent)20, transparent);
                 z-index: 0;
             }

             .ai-score-gauge > * {
                 position: relative;
                 z-index: 1;
             }

             .score-number {
                 font-size: 3rem;
                 font-weight: 800;
                 background: linear-gradient(135deg, var(--mcp-accent), var(--ai-glow));
                 -webkit-background-clip: text;
                 -webkit-text-fill-color: transparent;
                 background-clip: text;
             }

             .score-label {
                 font-size: 0.9rem;
                 color: var(--text-secondary);
                 margin-bottom: 10px;
             }

             .score-status {
                 padding: 6px 14px;
                 border-radius: 20px;
                 font-size: 0.8rem;
                 font-weight: 600;
                 text-transform: uppercase;
             }

             .score-status.excellent {
                 background: var(--success);
                 color: white;
             }
             .score-status.good {
                 background: var(--accent);
                 color: white;
             }
             .score-status.warning {
                 background: var(--warning);
                 color: var(--bg-primary);
             }
             .score-status.critical {
                 background: var(--danger);
                 color: white;
             }

             .ai-recommendations {
                 background: var(--bg-card);
                 border-radius: 12px;
                 padding: 20px;
                 margin-bottom: 20px;
             }

             .ai-recommendations h4 {
                 color: var(--ai-glow);
                 margin-bottom: 15px;
                 display: flex;
                 align-items: center;
                 gap: 8px;
             }

             .recommendation-item {
                 background: var(--bg-primary);
                 border: 1px solid var(--border);
                 border-radius: 8px;
                 padding: 12px;
                 margin-bottom: 10px;
                 font-size: 0.9rem;
                 line-height: 1.5;
             }

             .recommendation-item:last-child {
                 margin-bottom: 0;
             }

             .platform-status {
                 background: var(--bg-card);
                 border-radius: 12px;
                 padding: 20px;
             }

             .platform-status h4 {
                 color: var(--success);
                 margin-bottom: 15px;
                 display: flex;
                 align-items: center;
                 gap: 8px;
             }

             .platform-item {
                 display: flex;
                 justify-content: space-between;
                 align-items: center;
                 padding: 8px 0;
                 border-bottom: 1px solid var(--border);
             }

             .platform-item:last-child {
                 border-bottom: none;
             }

             .platform-name {
                 font-weight: 500;
             }

             .platform-url {
                 color: var(--text-secondary);
                 font-size: 0.8rem;
             }

             .platform-link {
                 background: var(--accent);
                 color: white;
                 padding: 4px 8px;
                 border-radius: 6px;
                 text-decoration: none;
                 font-size: 0.8rem;
                 transition: background-color 0.3s ease;
             }

             .platform-link:hover {
                 background: var(--mcp-accent);
             }

             /* Enhanced Device Cards */
             .devices-grid {
                 display: grid;
                 grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
                 gap: 20px;
             }

             .device-card {
                 background: var(--bg-secondary);
                 border: 1px solid var(--border);
                 border-radius: 12px;
                 padding: 20px;
                 transition: all 0.3s ease;
                 position: relative;
             }

             .device-card:hover {
                 border-color: var(--accent);
                 transform: translateY(-2px);
                 box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
             }

             .device-card.ai-enhanced {
                 border-color: var(--mcp-accent);
                 background: linear-gradient(135deg, var(--bg-secondary), var(--bg-secondary)f0);
             }

             .device-header {
                 display: flex;
                 justify-content: space-between;
                 align-items: flex-start;
                 margin-bottom: 15px;
             }

             .device-name {
                 font-weight: 600;
                 font-size: 1.1rem;
                 color: var(--text-primary);
             }

             .device-ip {
                 color: var(--text-secondary);
                 font-size: 0.9rem;
                 margin-top: 2px;
             }

             .device-actions {
                 display: flex;
                 gap: 8px;
             }

             .action-btn {
                 background: var(--bg-card);
                 border: 1px solid var(--border);
                 color: var(--text-secondary);
                 padding: 6px 8px;
                 border-radius: 6px;
                 cursor: pointer;
                 font-size: 0.8rem;
                 transition: all 0.3s ease;
             }

             .action-btn:hover {
                 background: var(--border);
                 color: var(--text-primary);
             }

             .action-btn.delete {
                 border-color: var(--danger);
                 color: var(--danger);
             }

             .action-btn.delete:hover {
                 background: var(--danger);
                 color: white;
             }

             .status-indicator {
                 display: flex;
                 align-items: center;
                 gap: 8px;
                 margin-bottom: 15px;
             }

             .status-dot {
                 width: 12px;
                 height: 12px;
                 border-radius: 50%;
                 animation: pulse 2s infinite;
             }

             .status-dot.online {
                 background: var(--success);
             }

             .status-dot.offline {
                 background: var(--danger);
                 animation: none;
             }

             @keyframes pulse {
                 0% { opacity: 1; }
                 50% { opacity: 0.5; }
                 100% { opacity: 1; }
             }

             .latency-display {
                 font-size: 2rem;
                 font-weight: 700;
                 color: var(--accent);
                 margin-bottom: 15px;
             }

             .latency-chart {
                 height: 100px;
                 background: var(--bg-primary);
                 border-radius: 8px;
                 padding: 10px;
                 overflow: hidden;
             }

             .latency-chart svg {
                 width: 100%;
                 height: 100%;
             }

             .sparkline {
                 fill: none;
                 stroke: var(--accent);
                 stroke-width: 2;
                 opacity: 0.8;
             }

             .ai-insights-mini {
                 background: linear-gradient(135deg, var(--mcp-accent)20, transparent);
                 border: 1px solid var(--mcp-accent);
                 border-radius: 8px;
                 padding: 12px;
                 margin-top: 15px;
             }

             .ai-insights-mini h5 {
                 color: var(--mcp-accent);
                 font-size: 0.9rem;
                 margin-bottom: 8px;
                 display: flex;
                 align-items: center;
                 gap: 6px;
             }

             .ai-metric {
                 display: flex;
                 justify-content: space-between;
                 font-size: 0.8rem;
                 margin-bottom: 4px;
             }

             .ai-metric:last-child {
                 margin-bottom: 0;
             }

             /* Add device form styles remain the same */
             .add-device-section {
                 background: var(--bg-secondary);
                 border: 1px solid var(--border);
                 border-radius: 12px;
                 margin-bottom: 30px;
                 overflow: hidden;
                 max-height: 0;
                 transition: all 0.3s ease;
             }

             .add-device-section.active {
                 max-height: 300px;
             }

             .add-device-form {
                 padding: 20px;
             }

             .form-group {
                 margin-bottom: 20px;
             }

             .form-group label {
                 display: block;
                 margin-bottom: 5px;
                 color: var(--text-secondary);
                 font-weight: 500;
             }

             .form-group input {
                 width: 100%;
                 background: var(--bg-primary);
                 border: 1px solid var(--border);
                 color: var(--text-primary);
                 padding: 12px;
                 border-radius: 8px;
                 font-size: 1rem;
             }

             .form-group input:focus {
                 outline: none;
                 border-color: var(--accent);
                 box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
             }

             .form-actions {
                 display: flex;
                 gap: 10px;
             }

             .btn {
                 background: var(--accent);
                 color: white;
                 border: none;
                 padding: 12px 20px;
                 border-radius: 8px;
                 cursor: pointer;
                 font-weight: 500;
                 transition: background-color 0.3s ease;
             }

             .btn:hover {
                 background: var(--mcp-accent);
             }

             .btn-secondary {
                 background: var(--bg-card);
                 color: var(--text-primary);
                 border: 1px solid var(--border);
             }

             .btn-secondary:hover {
                 background: var(--border);
             }

             /* Notification styles remain the same */
             .notification {
                 position: fixed;
                 top: 20px;
                 right: 20px;
                 background: var(--success);
                 color: white;
                 padding: 15px 20px;
                 border-radius: 8px;
                 transform: translateX(100%);
                 transition: transform 0.3s ease;
                 z-index: 1000;
             }

             .notification.show {
                 transform: translateX(0);
             }

             .notification.error {
                 background: var(--danger);
             }

             /* Loading states */
             .loading {
                 opacity: 0.6;
                 pointer-events: none;
             }

             .ai-loading {
                 display: inline-block;
                 width: 16px;
                 height: 16px;
                 border: 2px solid var(--mcp-accent);
                 border-radius: 50%;
                 border-top-color: transparent;
                 animation: spin 1s ease-in-out infinite;
             }

             @keyframes spin {
                 to { transform: rotate(360deg); }
             }

             /* Network Topology Map Styles */
             .topology-section {
                 background: var(--bg-secondary);
                 border: 1px solid var(--border);
                 border-radius: 12px;
                 margin-bottom: 30px;
                 padding: 20px;
             }

             .topology-header {
                 display: flex;
                 justify-content: space-between;
                 align-items: center;
                 margin-bottom: 20px;
             }

             .topology-map {
                 position: relative;
                 height: 300px;
                 background: var(--bg-primary);
                 border-radius: 8px;
                 overflow: hidden;
                 border: 1px solid var(--border);
             }

             .topology-node {
                 position: absolute;
                 width: 60px;
                 height: 60px;
                 border-radius: 50%;
                 display: flex;
                 align-items: center;
                 justify-content: center;
                 font-size: 1.5rem;
                 color: white;
                 cursor: pointer;
                 transition: all 0.3s ease;
                 border: 2px solid transparent;
             }

             .topology-node:hover {
                 transform: scale(1.1);
                 border-color: var(--ai-glow);
             }

             .topology-node.router { background: linear-gradient(135deg, #3b82f6, #1d4ed8); }
             .topology-node.pi { background: linear-gradient(135deg, #10b981, #059669); }
             .topology-node.iot { background: linear-gradient(135deg, #f59e0b, #d97706); }
             .topology-node.server { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
             .topology-node.offline { background: linear-gradient(135deg, #6b7280, #4b5563); }

             .topology-connection {
                 position: absolute;
                 height: 2px;
                 background: var(--border);
                 z-index: 1;
                 opacity: 0.6;
             }

             .topology-connection.active {
                 background: var(--success);
                 opacity: 1;
             }

             .device-label {
                 position: absolute;
                 top: 65px;
                 left: 50%;
                 transform: translateX(-50%);
                 font-size: 0.7rem;
                 color: var(--text-secondary);
                 white-space: nowrap;
                 pointer-events: none;
             }

             /* Device Category Styles */
             .category-tabs {
                 display: flex;
                 gap: 10px;
                 margin-bottom: 20px;
                 flex-wrap: wrap;
             }

             .category-tab {
                 background: var(--bg-card);
                 border: 1px solid var(--border);
                 color: var(--text-secondary);
                 padding: 8px 16px;
                 border-radius: 20px;
                 cursor: pointer;
                 font-size: 0.9rem;
                 transition: all 0.3s ease;
                 display: flex;
                 align-items: center;
                 gap: 6px;
             }

             .category-tab:hover {
                 border-color: var(--accent);
                 color: var(--text-primary);
             }

             .category-tab.active {
                 background: var(--accent);
                 color: white;
                 border-color: var(--accent);
             }

             .device-category {
                 display: none;
             }

             .device-category.active {
                 display: block;
             }

             /* Uptime Counter Styles */
             .uptime-counter {
                 background: linear-gradient(135deg, var(--success)20, transparent);
                 border: 1px solid var(--success);
                 border-radius: 6px;
                 padding: 4px 8px;
                 margin-top: 8px;
                 font-size: 0.8rem;
                 color: var(--success);
                 text-align: center;
             }

             .uptime-counter.offline {
                 background: linear-gradient(135deg, var(--danger)20, transparent);
                 border-color: var(--danger);
                 color: var(--danger);
             }

             /* Theme Toggle Styles */
             .theme-controls {
                 display: flex;
                 gap: 10px;
                 align-items: center;
             }

             .theme-toggle {
                 background: var(--bg-card);
                 border: 1px solid var(--border);
                 border-radius: 20px;
                 padding: 4px;
                 cursor: pointer;
                 transition: all 0.3s ease;
             }

             .theme-toggle:hover {
                 border-color: var(--accent);
             }

             .theme-option {
                 padding: 4px 12px;
                 border-radius: 16px;
                 font-size: 0.8rem;
                 transition: all 0.3s ease;
                 color: var(--text-secondary);
             }

             .theme-option.active {
                 background: var(--accent);
                 color: white;
             }
         </style>
     </head>
     <body>
         <div class="container">
             <div class="header">
                 <h1>
                     <i class="fas fa-network-wired"></i>
                     Network Latency Monitor
                     <span class="ai-badge">AI Enhanced</span>
                 </h1>
                 <div class="status-bar">
                     <div class="last-update">
                         Last update: <span id="timestamp">-</span>
                         <span id="quiet-hours-indicator" style="color: var(--warning); margin-left: 10px; display: none;">
                             üåô Quiet Hours
                         </span>
                     </div>
                     <div class="theme-controls">
                         <div class="theme-toggle" id="theme-toggle">
                             <span class="theme-option active" id="dark-theme">üåô</span>
                             <span class="theme-option" id="light-theme">‚òÄÔ∏è</span>
                         </div>
                         <button class="toggle-btn" id="topology-toggle-btn">
                             <i class="fas fa-project-diagram"></i>
                             Topology
                         </button>
                         <button class="toggle-btn ai-mode" id="ai-toggle-btn">
                             <i class="fas fa-brain"></i>
                             AI Insights
                         </button>
                         <button class="toggle-btn active" id="auto-refresh-btn">
                             <i class="fas fa-sync-alt"></i>
                             Auto Refresh
                         </button>
                     </div>
                 </div>
             </div>

             <div class="main-layout">
                 <div class="main-content">
                     <!-- Network Topology Map -->
                     <div class="topology-section" id="topology-section" style="display: none;">
                         <div class="topology-header">
                             <h3><i class="fas fa-project-diagram"></i> Network Topology</h3>
                             <small class="text-secondary">Visual representation of your homelab network</small>
                         </div>
                         <div class="topology-map" id="topology-map">
                             <!-- Topology nodes will be generated here -->
                         </div>
                     </div>

                     <!-- Statistics Grid -->
                     <div class="stats-grid">
                         <div class="stat-card">
                             <div class="stat-number" id="total-devices">0</div>
                             <div class="stat-label">Total Devices</div>
                         </div>
                         <div class="stat-card online">
                             <div class="stat-number" id="online-devices">0</div>
                             <div class="stat-label">Online</div>
                         </div>
                         <div class="stat-card offline">
                             <div class="stat-number" id="offline-devices">0</div>
                             <div class="stat-label">Offline</div>
                         </div>
                         <div class="stat-card latency">
                             <div class="stat-number" id="avg-latency">-</div>
                             <div class="stat-label">Avg Latency (ms)</div>
                         </div>
                     </div>

                     <!-- Device Category Tabs -->
                     <div class="category-tabs" id="category-tabs">
                         <div class="category-tab active" data-category="all">
                             <i class="fas fa-th"></i> All Devices
                         </div>
                         <div class="category-tab" data-category="router">
                             <i class="fas fa-wifi"></i> Routers
                         </div>
                         <div class="category-tab" data-category="pi">
                             <i class="fab fa-raspberry-pi"></i> Raspberry Pi
                         </div>
                         <div class="category-tab" data-category="iot">
                             <i class="fas fa-microchip"></i> IoT Devices
                         </div>
                         <div class="category-tab" data-category="server">
                             <i class="fas fa-server"></i> Servers
                         </div>
                     </div>

                     <!-- Add Device Section -->
                     <button class="toggle-btn" onclick="toggleAddDevice()">
                         <i class="fas fa-plus"></i>
                         Add Device
                     </button>

                     <div class="add-device-section" id="add-device-section">
                         <form class="add-device-form" id="device-form">
                             <div class="form-group">
                                 <label for="device-name">Device Name</label>
                                 <input type="text" id="device-name" name="name" required>
                             </div>
                             <div class="form-group">
                                 <label for="device-ip">IP Address</label>
                                 <input type="text" id="device-ip" name="ip" required pattern="^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$">
                             </div>
                             <div class="form-actions">
                                 <button type="submit" class="btn">Add Device</button>
                                 <button type="button" class="btn btn-secondary" onclick="toggleAddDevice()">Cancel</button>
                             </div>
                         </form>
                     </div>

                     <!-- Devices Grid -->
                     <div class="devices-grid" id="devices-container">
                         <!-- Device cards will be populated here -->
                     </div>
                 </div>

                 <!-- AI Sidebar -->
                 <div class="ai-sidebar" id="ai-sidebar">
                     <div class="ai-panel-header">
                         <i class="fas fa-brain"></i>
                         <h3>AI Network Intelligence</h3>
                         <div class="ai-loading" id="ai-loading" style="display: none;"></div>
                     </div>

                     <!-- AI Network Score -->
                     <div class="ai-score-gauge">
                         <div class="score-label">Network Performance Score</div>
                         <div class="score-number" id="ai-score">--</div>
                         <div class="score-status" id="ai-status">Analyzing...</div>
                     </div>

                     <!-- AI Recommendations -->
                     <div class="ai-recommendations">
                         <h4>
                             <i class="fas fa-lightbulb"></i>
                             Smart Recommendations
                         </h4>
                         <div id="ai-recommendations-list">
                             <div class="recommendation-item">
                                 üîç Analyzing network patterns...
                             </div>
                         </div>
                     </div>

                     <!-- Platform Status -->
                     <div class="platform-status">
                         <h4>
                             <i class="fas fa-network-wired"></i>
                             Connected Platforms
                         </h4>
                         <div id="platform-status-list">
                             <div class="platform-item">
                                 <div>
                                     <div class="platform-name">Discovering platforms...</div>
                                 </div>
                             </div>
                         </div>
                     </div>
                 </div>
             </div>
         </div>

         <!-- Notification -->
         <div class="notification" id="notification">
             <span id="notification-text">Notification</span>
         </div>

         <script>
             // Global variables
             let autoRefresh = true;
             let aiInsightsEnabled = true;
             let deviceHistory = {};
             let deviceStates = {}; // Track online/offline states for alerting
             let deviceUptime = {}; // Track device uptime
             let aiData = null;
             let platformData = null;
             let currentTheme = 'dark';
             let topologyVisible = false;
             let activeCategory = 'all';
             const HISTORY_POINTS = 50;

             // Optional Server Configuration (All integrations are optional and non-disruptive)
             // These will be loaded from backend API endpoint which reads environment variables
             let AI_SERVER_URL = '';
             let LOGGING_SERVER_URL = '';
             let WEBHOOK_URL = '';
             let PLATFORM_URLS = {};

             // DOM elements
             const timestampEl = document.getElementById('timestamp');
             const devicesContainer = document.getElementById('devices-container');
             const totalDevicesEl = document.getElementById('total-devices');
             const onlineDevicesEl = document.getElementById('online-devices');
             const offlineDevicesEl = document.getElementById('offline-devices');
             const avgLatencyEl = document.getElementById('avg-latency');
             const autoRefreshBtn = document.getElementById('auto-refresh-btn');
             const aiToggleBtn = document.getElementById('ai-toggle-btn');
             const aiSidebar = document.getElementById('ai-sidebar');
             const aiScoreEl = document.getElementById('ai-score');
             const aiStatusEl = document.getElementById('ai-status');
             const aiRecommendationsEl = document.getElementById('ai-recommendations-list');
             const platformStatusEl = document.getElementById('platform-status-list');
             const aiLoadingEl = document.getElementById('ai-loading');
             const notification = document.getElementById('notification');
             const notificationText = document.getElementById('notification-text');
             
             // New feature elements
             const topologyToggleBtn = document.getElementById('topology-toggle-btn');
             const topologySection = document.getElementById('topology-section');
             const topologyMap = document.getElementById('topology-map');
             const themeToggle = document.getElementById('theme-toggle');
             const darkTheme = document.getElementById('dark-theme');
             const lightTheme = document.getElementById('light-theme');
             const quietHoursIndicator = document.getElementById('quiet-hours-indicator');
             const categoryTabs = document.querySelectorAll('.category-tab');

             // Toggle auto refresh
             autoRefreshBtn.addEventListener('click', () => {
                 autoRefresh = !autoRefresh;
                 autoRefreshBtn.classList.toggle('active');
                 showNotification(autoRefresh ? 'Auto refresh enabled' : 'Auto refresh disabled', 'success');
             });

             // Toggle AI insights
             aiToggleBtn.addEventListener('click', () => {
                 aiInsightsEnabled = !aiInsightsEnabled;
                 aiToggleBtn.classList.toggle('active');
                 aiSidebar.classList.toggle('hidden');
                 showNotification(aiInsightsEnabled ? 'AI insights enabled' : 'AI insights disabled', 'success');
             });

             // Toggle Network Topology
             topologyToggleBtn.addEventListener('click', () => {
                 topologyVisible = !topologyVisible;
                 topologyToggleBtn.classList.toggle('active');
                 topologySection.style.display = topologyVisible ? 'block' : 'none';
                 showNotification(topologyVisible ? 'Topology map enabled' : 'Topology map disabled', 'success');
                 if (topologyVisible) {
                     renderTopologyMap();
                 }
             });

             // Theme Toggle
             themeToggle.addEventListener('click', (e) => {
                 if (e.target.id === 'light-theme') {
                     currentTheme = 'light';
                     document.documentElement.classList.add('light-theme');
                     darkTheme.classList.remove('active');
                     lightTheme.classList.add('active');
                 } else if (e.target.id === 'dark-theme') {
                     currentTheme = 'dark';
                     document.documentElement.classList.remove('light-theme');
                     lightTheme.classList.remove('active');
                     darkTheme.classList.add('active');
                 }
                 showNotification(`Switched to ${currentTheme} theme`, 'success');
             });

             // Category Tabs
             categoryTabs.forEach(tab => {
                 tab.addEventListener('click', () => {
                     categoryTabs.forEach(t => t.classList.remove('active'));
                     tab.classList.add('active');
                     activeCategory = tab.dataset.category;
                     filterDevicesByCategory();
                 });
             });

             // Show notification
             function showNotification(message, type = 'success') {
                 notificationText.textContent = message;
                 notification.className = `notification ${type} show`;
                 setTimeout(() => {
                     notification.classList.remove('show');
                 }, 3000);
             }

             // Logging Integration - Send network events to external logging system (NON-DISRUPTIVE)
             async function logNetworkEvent(event_type, data) {
                 if (!LOGGING_SERVER_URL) return; // Skip if not configured

                 try {
                     const controller = new AbortController();
                     setTimeout(() => controller.abort(), 1000); // 1 second timeout

                     await fetch(`${LOGGING_SERVER_URL}/api/events`, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({
                             source: 'LatencyMonitor',
                             event_type: event_type,
                             timestamp: new Date().toISOString(),
                             data: data
                         }),
                         signal: controller.signal
                     });
                 } catch (error) {
                     // COMPLETELY SILENT - never disrupts main functionality
                     // Only log to console in debug mode
                     if (window.location.search.includes('debug=1')) {
                         console.debug('Logging server unavailable:', error);
                     }
                 }
             }

             // Webhook Integration - Send alerts to webhook (NON-DISRUPTIVE)
             async function sendWebhookAlert(title, message, color = 3447003) {
                 if (!WEBHOOK_URL) return; // Skip if not configured

                 try {
                     const controller = new AbortController();
                     setTimeout(() => controller.abort(), 2000); // 2 second timeout

                     await fetch(WEBHOOK_URL, {
                         method: 'POST',
                         headers: { 'Content-Type': 'application/json' },
                         body: JSON.stringify({
                             embeds: [{
                                 title: `üåê Network Alert: ${title}`,
                                 description: message,
                                 color: color,
                                 timestamp: new Date().toISOString(),
                                 footer: { text: 'LatencyMonitor AI' }
                             }]
                         }),
                         signal: controller.signal
                     });
                 } catch (error) {
                     // COMPLETELY SILENT - never disrupts main functionality
                     if (window.location.search.includes('debug=1')) {
                         console.debug('Discord unavailable:', error);
                     }
                 }
             }

             // Browser notification for network alerts
             function showBrowserNotification(title, message) {
                 if ('Notification' in window && Notification.permission === 'granted') {
                     new Notification(title, {
                         body: message,
                         icon: '/static/icon.png' // Add an icon if available
                     });
                 }
             }

             // Request notification permission on page load
             if ('Notification' in window && Notification.permission === 'default') {
                 Notification.requestPermission();
             }

             // Quiet Hours Detection (11PM - 7AM)
             function checkQuietHours() {
                 const now = new Date();
                 const hour = now.getHours();
                 const isQuietHours = hour >= 23 || hour < 7;
                 
                 if (isQuietHours) {
                     document.body.classList.add('quiet-hours');
                     quietHoursIndicator.style.display = 'inline';
                 } else {
                     document.body.classList.remove('quiet-hours');
                     quietHoursIndicator.style.display = 'none';
                 }
                 
                 return isQuietHours;
             }

             // Device Category Classification
             function categorizeDevice(name, ip) {
                 const deviceName = name.toLowerCase();
                 const deviceIP = ip.toLowerCase();
                 
                 if (deviceName.includes('router') || deviceName.includes('gateway') || ip.endsWith('.1')) {
                     return 'router';
                 } else if (deviceName.includes('pi') || deviceName.includes('raspberry')) {
                     return 'pi';
                 } else if (deviceName.includes('server') || deviceName.includes('nas') || deviceName.includes('vm')) {
                     return 'server';
                 } else {
                     return 'iot'; // Default for other devices
                 }
             }

             // Filter Devices by Category
             function filterDevicesByCategory() {
                 const deviceCards = document.querySelectorAll('.device-card');
                 deviceCards.forEach(card => {
                     if (activeCategory === 'all') {
                         card.style.display = 'block';
                     } else {
                         const category = card.dataset.category;
                         card.style.display = category === activeCategory ? 'block' : 'none';
                     }
                 });
             }

             // Calculate Device Uptime
             function calculateUptime(deviceName, isOnline) {
                 if (!deviceUptime[deviceName]) {
                     deviceUptime[deviceName] = {
                         lastOnline: isOnline ? Date.now() : null,
                         totalUptime: 0,
                         lastCheck: Date.now()
                     };
                     return 'Just added';
                 }

                 const device = deviceUptime[deviceName];
                 const now = Date.now();
                 const timeDiff = now - device.lastCheck;

                 if (isOnline) {
                     if (device.lastOnline) {
                         device.totalUptime += timeDiff;
                     } else {
                         device.lastOnline = now;
                     }
                 } else {
                     device.lastOnline = null;
                 }

                 device.lastCheck = now;

                 if (!isOnline) {
                     return 'Offline';
                 }

                 const uptimeMs = device.totalUptime;
                 const days = Math.floor(uptimeMs / (1000 * 60 * 60 * 24));
                 const hours = Math.floor((uptimeMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                 const minutes = Math.floor((uptimeMs % (1000 * 60 * 60)) / (1000 * 60));

                 if (days > 0) {
                     return `${days}d ${hours}h`;
                 } else if (hours > 0) {
                     return `${hours}h ${minutes}m`;
                 } else {
                     return `${minutes}m`;
                 }
             }

             // Render Network Topology Map
             function renderTopologyMap() {
                 if (!topologyVisible) return;
                 
                 topologyMap.innerHTML = '';
                 
                 // Get router (gateway) position - center
                 const centerX = topologyMap.offsetWidth / 2;
                 const centerY = topologyMap.offsetHeight / 2;
                 
                 const devices = Object.entries(deviceStates);
                 const routerDevices = devices.filter(([name, state]) => categorizeDevice(name, '') === 'router');
                 const otherDevices = devices.filter(([name, state]) => categorizeDevice(name, '') !== 'router');
                 
                 // Add router in center
                 if (routerDevices.length > 0) {
                     const [routerName, routerState] = routerDevices[0];
                     addTopologyNode(routerName, centerX - 30, centerY - 30, 'router', routerState);
                 }
                 
                 // Add other devices in a circle around the router
                 otherDevices.forEach(([name, state], index) => {
                     const angle = (2 * Math.PI * index) / otherDevices.length;
                     const radius = 100;
                     const x = centerX + Math.cos(angle) * radius - 30;
                     const y = centerY + Math.sin(angle) * radius - 30;
                     const category = categorizeDevice(name, '');
                     
                     addTopologyNode(name, x, y, category, state);
                     
                     // Add connection line to router
                     if (routerDevices.length > 0) {
                         addTopologyConnection(centerX, centerY, x + 30, y + 30, state);
                     }
                 });
             }
             
             function addTopologyNode(name, x, y, category, isOnline) {
                 const node = document.createElement('div');
                 node.className = `topology-node ${category} ${!isOnline ? 'offline' : ''}`;
                 node.style.left = x + 'px';
                 node.style.top = y + 'px';
                 node.title = `${name} (${category})`;
                 
                 const icons = {
                     router: 'üè†',
                     pi: 'ü•ß',
                     iot: 'üì±',
                     server: 'üñ•Ô∏è'
                 };
                 
                 node.innerHTML = icons[category] || 'üì±';
                 
                 const label = document.createElement('div');
                 label.className = 'device-label';
                 label.textContent = name;
                 node.appendChild(label);
                 
                 topologyMap.appendChild(node);
             }
             
             function addTopologyConnection(x1, y1, x2, y2, isActive) {
                 const connection = document.createElement('div');
                 connection.className = `topology-connection ${isActive ? 'active' : ''}`;
                 
                 const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                 const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                 
                 connection.style.width = length + 'px';
                 connection.style.left = x1 + 'px';
                 connection.style.top = y1 + 'px';
                 connection.style.transform = `rotate(${angle}deg)`;
                 connection.style.transformOrigin = '0 50%';
                 
                 topologyMap.appendChild(connection);
             }

             // Toggle add device form
             function toggleAddDevice() {
                 const section = document.getElementById('add-device-section');
                 section.classList.toggle('active');
                 if (section.classList.contains('active')) {
                     document.querySelector('.add-device-form input[name="name"]').focus();
                 }
             }

             // Create sparkline chart (enhanced version)
             function createSparkline(data, deviceName) {
                 if (!data || data.length === 0) return '';

                 const width = 350;
                 const height = 100;
                 const padding = 10;

                 const max = Math.max(...data, 100);
                 const min = 0;

                 const xScale = (i) => (i / (data.length - 1)) * (width - 2 * padding) + padding;
                 const yScale = (v) => height - ((v - min) / (max - min)) * (height - 2 * padding) - padding;

                 const points = data.map((v, i) => `${xScale(i)},${yScale(v)}`).join(' ');

                 // Enhanced sparkline with gradient and better styling
                 const avgLatency = data.reduce((a, b) => a + b, 0) / data.length;
                 const strokeColor = avgLatency < 50 ? '#10b981' : avgLatency < 100 ? '#3b82f6' : '#f59e0b';

                 return `
                     <svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                         <defs>
                             <linearGradient id="gradient-${deviceName}" x1="0%" y1="0%" x2="0%" y2="100%">
                                 <stop offset="0%" style="stop-color:${strokeColor};stop-opacity:0.3" />
                                 <stop offset="100%" style="stop-color:${strokeColor};stop-opacity:0" />
                             </linearGradient>
                         </defs>
                         <polyline class="sparkline" points="${points}" style="stroke: ${strokeColor};" />
                         <polygon points="${points} ${width-padding},${height-padding} ${padding},${height-padding}"
                                  fill="url(#gradient-${deviceName})" />
                     </svg>
                 `;
             }

             // Create AI insights for device
             function createDeviceAIInsights(device, deviceName) {
                 if (!aiData || !aiInsightsEnabled) return '';

                 const history = deviceHistory[deviceName] || [];
                 if (history.length < 5) return ''; // Need some history for AI insights

                 const avgLatency = history.reduce((a, b) => a + b, 0) / history.length;
                 const maxLatency = Math.max(...history);
                 const minLatency = Math.min(...history);
                 const variance = history.reduce((acc, val) => acc + Math.pow(val - avgLatency, 2), 0) / history.length;
                 const jitter = Math.sqrt(variance);

                 const quality = avgLatency < 20 ? 'Excellent' : avgLatency < 50 ? 'Good' : avgLatency < 100 ? 'Fair' : 'Poor';
                 const stability = jitter < 5 ? 'Very Stable' : jitter < 15 ? 'Stable' : jitter < 30 ? 'Moderate' : 'Unstable';

                 return `
                     <div class="ai-insights-mini">
                         <h5><i class="fas fa-brain"></i> AI Analysis</h5>
                         <div class="ai-metric">
                             <span>Quality:</span>
                             <span style="color: ${avgLatency < 50 ? 'var(--success)' : avgLatency < 100 ? 'var(--accent)' : 'var(--warning)'}">${quality}</span>
                         </div>
                         <div class="ai-metric">
                             <span>Stability:</span>
                             <span style="color: ${jitter < 15 ? 'var(--success)' : jitter < 30 ? 'var(--accent)' : 'var(--warning)'}">${stability}</span>
                         </div>
                         <div class="ai-metric">
                             <span>Jitter:</span>
                             <span>${jitter.toFixed(1)}ms</span>
                         </div>
                         <div class="ai-metric">
                             <span>Range:</span>
                             <span>${minLatency.toFixed(1)} - ${maxLatency.toFixed(1)}ms</span>
                         </div>
                     </div>
                 `;
             }

             // Fetch AI insights
             async function fetchAIInsights() {
                 if (!aiInsightsEnabled) return;

                 aiLoadingEl.style.display = 'inline-block';

                 try {
                     const aiResponse = await performAIAnalysis();
                     aiData = aiResponse;
                     updateAIInterface();

                 } catch (error) {
                     console.error('Failed to fetch AI insights:', error);
                     showNotification('AI analysis temporarily unavailable', 'error');
                 } finally {
                     aiLoadingEl.style.display = 'none';
                 }
             }

             // AI Analysis with Optional External Server Integration
             async function performAIAnalysis() {
                 try {
                     // Try external AI server if configured
                     if (AI_SERVER_URL) {
                         const aiResponse = await fetch(`${AI_SERVER_URL}/api/tools/analyze_network`, {
                             method: 'POST',
                             headers: { 'Content-Type': 'application/json' },
                             body: JSON.stringify({
                                 name: 'analyze_network',
                                 arguments: {
                                     devices: Object.keys(deviceHistory),
                                     latency_data: deviceHistory
                                 }
                             }),
                             signal: AbortSignal.timeout(5000)
                         });

                         if (aiResponse.ok) {
                             const aiData = await aiResponse.json();
                             if (aiData.success) {
                                 // Log successful AI analysis
                                 logNetworkEvent('ai_analysis', {
                                     score: aiData.network_score,
                                     status: aiData.status,
                                     recommendations: aiData.recommendations?.length || 0
                                 });
                                 return aiData;
                             }
                         }
                     }
                 } catch (error) {
                     console.log('External AI server unavailable, using local analysis:', error);
                     // Log AI server unavailability (non-disruptive)
                     logNetworkEvent('ai_fallback', { reason: error.message.substring(0, 100) });
                 }

                 // Local AI analysis (fallback)
                 await new Promise(resolve => setTimeout(resolve, 500));

                 // Calculate network score based on current devices
                 let totalLatency = 0;
                 let deviceCount = 0;
                 let onlineCount = 0;

                 for (const [name, history] of Object.entries(deviceHistory)) {
                     if (history.length > 0) {
                         const avg = history.reduce((a, b) => a + b, 0) / history.length;
                         totalLatency += avg;
                         deviceCount++;
                         onlineCount++;
                     }
                 }

                 const avgNetworkLatency = deviceCount > 0 ? totalLatency / deviceCount : 0;
                 let networkScore = 100;
                 let status = 'excellent';
                 const recommendations = [];

                 if (avgNetworkLatency > 100) {
                     networkScore -= 30;
                     status = 'warning';
                     recommendations.push('High latency detected - consider network optimization');
                 } else if (avgNetworkLatency > 50) {
                     networkScore -= 15;
                     status = 'good';
                     recommendations.push('Moderate latency - monitor for improvements');
                 }

                 if (onlineCount < 3) {
                     networkScore -= 10;
                     recommendations.push('Limited device visibility - consider adding more monitors');
                 }

                 if (recommendations.length === 0) {
                     recommendations.push('Network performance is optimal');
                     recommendations.push('All monitored devices showing good connectivity');
                 }

                 // Build platform list from configured URLs
                 const platforms = {};
                 if (PLATFORM_URLS.monitor) platforms['Network Monitor'] = { url: PLATFORM_URLS.monitor, status: 'online' };
                 if (PLATFORM_URLS.logs) platforms['Logging Server'] = { url: PLATFORM_URLS.logs, status: 'online' };
                 if (PLATFORM_URLS.ai) platforms['AI Server'] = { url: PLATFORM_URLS.ai, status: 'online' };

                 return {
                     ai_insights: {
                         network_score: Math.max(networkScore, 0),
                         status: status,
                         overall_avg_latency: avgNetworkLatency.toFixed(1),
                         performance_rating: avgNetworkLatency < 20 ? 'Excellent' :
                                           avgNetworkLatency < 50 ? 'Good' :
                                           avgNetworkLatency < 100 ? 'Fair' : 'Poor'
                     },
                     recommendations: recommendations,
                     platform_discovery: platforms
                 };
             }

             // Update AI interface
             function updateAIInterface() {
                 if (!aiData || !aiInsightsEnabled) return;

                 const insights = aiData.ai_insights;

                 // Update AI score
                 aiScoreEl.textContent = insights.network_score;
                 aiStatusEl.textContent = insights.status.toUpperCase();
                 aiStatusEl.className = `score-status ${insights.status}`;

                 // Update recommendations
                 aiRecommendationsEl.innerHTML = '';
                 aiData.recommendations.forEach(rec => {
                     const item = document.createElement('div');
                     item.className = 'recommendation-item';
                     item.innerHTML = `<i class="fas fa-lightbulb" style="color: var(--ai-glow); margin-right: 8px;"></i> ${rec}`;
                     aiRecommendationsEl.appendChild(item);
                 });

                 // Update platform status
                 platformStatusEl.innerHTML = '';
                 for (const [name, platform] of Object.entries(aiData.platform_discovery)) {
                     const item = document.createElement('div');
                     item.className = 'platform-item';
                     item.innerHTML = `
                         <div>
                             <div class="platform-name">${name}</div>
                             <div class="platform-url">${platform.url}</div>
                         </div>
                         <a href="${platform.url}" target="_blank" class="platform-link">
                             <i class="fas fa-external-link-alt"></i>
                         </a>
                     `;
                     platformStatusEl.appendChild(item);
                 }
             }

             // Delete device
             async function deleteDevice(name) {
                 if (!confirm(`Are you sure you want to delete ${name}?`)) return;

                 try {
                     const response = await fetch('/api/devices', {
                         method: 'DELETE',
                         headers: {
                             'Content-Type': 'application/json'
                         },
                         body: JSON.stringify({ name })
                     });

                     if (response.ok) {
                         showNotification(`${name} deleted successfully`);
                         delete deviceHistory[name];
                         updateData();
                     } else {
                         showNotification('Failed to delete device', 'error');
                     }
                 } catch (error) {
                     console.error('Error:', error);
                     showNotification('Network error', 'error');
                 }
             }

             // Update dashboard data (enhanced version)
             async function updateData() {
                 try {
                     const response = await fetch('/api/data');
                     const data = await response.json();

                     if (data.error) {
                         console.error(data.error);
                         return;
                     }

                     // Update timestamp
                     timestampEl.textContent = new Date(data.timestamp).toLocaleTimeString();

                     // Update device history and track state changes for homelab alerts
                     for (const [name, device] of Object.entries(data.devices)) {
                         if (!deviceHistory[name]) {
                             deviceHistory[name] = [];
                         }
                         
                         // Track device state changes for Discord alerts
                         const previousState = deviceStates[name];
                         deviceStates[name] = device.reachable;
                         
                         // Send Discord alert on state change (non-disruptive)
                         if (previousState !== undefined && previousState !== device.reachable) {
                             if (device.reachable) {
                                 sendWebhookAlert(
                                     `Device Online: ${name}`, 
                                     `üì± ${name} (${device.ip}) is back online with ${device.latency.toFixed(1)}ms latency`,
                                     65280 // Green color
                                 );
                                 logNetworkEvent('device_online', { name, ip: device.ip, latency: device.latency });
                             } else {
                                 sendWebhookAlert(
                                     `Device Offline: ${name}`, 
                                     `üî¥ ${name} (${device.ip}) has gone offline`,
                                     16711680 // Red color
                                 );
                                 logNetworkEvent('device_offline', { name, ip: device.ip });
                             }
                         }
                         
                         if (device.reachable) {
                             deviceHistory[name].push(device.latency);
                             if (deviceHistory[name].length > HISTORY_POINTS) {
                                 deviceHistory[name].shift();
                             }
                             
                             // Alert on high latency (homelab-friendly threshold)
                             if (device.latency > 200 && deviceHistory[name].length > 5) {
                                 const avg = deviceHistory[name].reduce((a, b) => a + b, 0) / deviceHistory[name].length;
                                 if (avg > 150) {
                                     sendWebhookAlert(
                                         `High Latency: ${name}`,
                                         `‚ö†Ô∏è ${name} showing consistently high latency: ${device.latency.toFixed(1)}ms (avg: ${avg.toFixed(1)}ms)`,
                                         16776960 // Orange color
                                     );
                                 }
                             }
                         }
                     }

                     // Calculate stats
                     let totalDevices = 0;
                     let onlineDevices = 0;
                     let offlineDevices = 0;
                     let totalLatency = 0;
                     let latencyCount = 0;

                     // Clear container
                     devicesContainer.innerHTML = '';

                     // Create device cards (enhanced with AI)
                     for (const [name, device] of Object.entries(data.devices)) {
                         totalDevices++;
                         if (device.reachable) {
                             onlineDevices++;
                             totalLatency += device.latency;
                             latencyCount++;
                         } else {
                             offlineDevices++;
                         }

                         // Categorize device and calculate uptime
                         const category = categorizeDevice(name, device.ip);
                         const uptime = calculateUptime(name, device.reachable);
                         
                         const card = document.createElement('div');
                         card.className = `device-card ${aiInsightsEnabled ? 'ai-enhanced' : ''}`;
                         card.dataset.category = category;
                         
                         const categoryIcons = {
                             router: 'üè†',
                             pi: 'ü•ß',
                             iot: 'üì±',
                             server: 'üñ•Ô∏è'
                         };
                         
                         card.innerHTML = `
                             <div class="device-header">
                                 <div>
                                     <div class="device-name">
                                         ${categoryIcons[category]} ${name}
                                         <span style="font-size: 0.7rem; color: var(--text-secondary); margin-left: 8px;">(${category})</span>
                                     </div>
                                     <div class="device-ip">${device.ip}</div>
                                 </div>
                                 <div class="device-actions">
                                     <button class="action-btn delete" onclick="deleteDevice('${name}')">
                                         <i class="fas fa-trash"></i>
                                     </button>
                                 </div>
                             </div>
                             <div class="status-indicator">
                                 <div class="status-dot ${device.reachable ? 'online' : 'offline'}"></div>
                                 <span>${device.reachable ? 'Online' : 'Offline'}</span>
                             </div>
                             <div class="uptime-counter ${!device.reachable ? 'offline' : ''}">
                                 <i class="fas fa-clock"></i> Uptime: ${uptime}
                             </div>
                             ${device.reachable ? `
                                 <div class="latency-display">${device.latency.toFixed(1)} ms</div>
                                 <div class="latency-chart">
                                     ${createSparkline(deviceHistory[name] || [], name)}
                                 </div>
                                 ${createDeviceAIInsights(device, name)}
                             ` : '<div class="latency-display">-</div>'}
                         `;
                         devicesContainer.appendChild(card);
                     }

                     // Update stats
                     totalDevicesEl.textContent = totalDevices;
                     onlineDevicesEl.textContent = onlineDevices;
                     offlineDevicesEl.textContent = offlineDevices;
                     avgLatencyEl.textContent = latencyCount > 0 ? (totalLatency / latencyCount).toFixed(1) : '-';

                     // Apply category filtering and update topology
                     filterDevicesByCategory();
                     if (topologyVisible) {
                         renderTopologyMap();
                     }
                     
                     // Check quiet hours
                     checkQuietHours();

                     // Update AI insights periodically
                     if (aiInsightsEnabled && Math.random() < 0.3) { // 30% chance to update AI on each refresh
                         fetchAIInsights();
                     }

                 } catch (error) {
                     console.error('Failed to fetch data:', error);
                     showNotification('Failed to fetch data', 'error');
                 }
             }

             // Handle device form submission
             document.getElementById('device-form').addEventListener('submit', async (e) => {
                 e.preventDefault();
                 const formData = new FormData(e.target);

                 try {
                     const response = await fetch('/api/devices', {
                         method: 'POST',
                         headers: {
                             'Content-Type': 'application/json'
                         },
                         body: JSON.stringify({
                             name: formData.get('name'),
                             ip: formData.get('ip')
                         })
                     });

                     if (response.ok) {
                         showNotification('Device added successfully!');
                         e.target.reset();
                         toggleAddDevice();
                         updateData();
                     } else {
                         showNotification('Failed to add device', 'error');
                     }
                 } catch (error) {
                     console.error('Error:', error);
                     showNotification('Network error', 'error');
                 }
             });

             // Auto-refresh with AI insights
             setInterval(() => {
                 if (autoRefresh) updateData();
             }, 2000);

             // Load configuration from backend API
             async function loadConfig() {
                 try {
                     const response = await fetch('/api/config');
                     if (response.ok) {
                         const config = await response.json();
                         AI_SERVER_URL = config.ai_server_url || '';
                         LOGGING_SERVER_URL = config.logging_server_url || '';
                         WEBHOOK_URL = config.webhook_url || '';
                         PLATFORM_URLS = config.platform_urls || {};
                     }
                 } catch (error) {
                     console.log('Config loading failed, using defaults:', error);
                 }
             }

             // Initial AI insights fetch
             setTimeout(() => {
                 fetchAIInsights();
             }, 3000); // Delay initial AI fetch to let devices load first

             // Send startup notification via webhook (non-disruptive)
             sendWebhookAlert(
                 'LatencyMonitor Started',
                 'üöÄ Network LatencyMonitor with AI enhancements is now online!\n\n‚ú® Features:\nüìä Network Topology Map\n‚è∞ Quiet Hours Mode\nüåô Dark/Light Theme Toggle\nüìç Device Categories\nüéÆ Device Uptime Tracking',
                 3447003 // Blue color
             );

             // Initial setup
             async function initialize() {
                 await loadConfig();
                 checkQuietHours();
                 updateData();
             }

             // Check quiet hours every minute
             setInterval(checkQuietHours, 60000);

             // Start the application
             initialize();
         </script>
     </body>
     </html>
